/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
/// <reference path="../vendor/jquery.d.ts" />
/// <reference path="../vendor/strophe.d.ts" />
// Keep in sync with Race enum on client and server
var Race;
(function (Race) {
    //Tuatha = 0,
    Race[Race["Hamadryad"] = 1] = "Hamadryad";
    Race[Race["Luchorpan"] = 2] = "Luchorpan";
    Race[Race["Firbog"] = 3] = "Firbog";
    Race[Race["Valkyrie"] = 4] = "Valkyrie";
    Race[Race["Helbound"] = 5] = "Helbound";
    Race[Race["FrostGiant"] = 6] = "FrostGiant";
    //Dvergr = 7,
    Race[Race["Strm"] = 8] = "Strm";
    Race[Race["CaitSith"] = 9] = "CaitSith";
    Race[Race["Golem"] = 10] = "Golem";
    //Gargoyle = 11
    Race[Race["StormRider"] = 12] = "StormRider";
    Race[Race["StormRiderT"] = 13] = "StormRiderT";
    Race[Race["StormRiderV"] = 14] = "StormRiderV";
    Race[Race["HumanMaleV"] = 15] = "HumanMaleV";
    Race[Race["HumanMaleA"] = 16] = "HumanMaleA";
    Race[Race["HumanMaleT"] = 17] = "HumanMaleT";
})(Race || (Race = {}));
var Archetype;
(function (Archetype) {
    Archetype[Archetype["FireMage"] = 0] = "FireMage";
    Archetype[Archetype["EarthMage"] = 1] = "EarthMage";
    Archetype[Archetype["WaterMage"] = 2] = "WaterMage";
    Archetype[Archetype["Fighter"] = 3] = "Fighter";
    Archetype[Archetype["Healer"] = 4] = "Healer";
    Archetype[Archetype["MeleeCombatTest"] = 5] = "MeleeCombatTest";
    Archetype[Archetype["ArcherTest"] = 6] = "ArcherTest";
})(Archetype || (Archetype = {}));
// AUDIO events - todo have these pulled from a file generated by the editor or
// from parsing the output from Wwise.
var SoundEvents = {
    PLAY_LOADINGSCREEN: 3149737762,
    PLAY_LOADINGSCREEN_COMPLETE: 3341534392,
    PLAY_MAGIC_HEALING_BANDAGE_END: 107096549,
    PLAY_MAGIC_HEALING_BANDAGE_START: 3552760942,
    PLAY_MAINMENU: 3738780720,
    PLAY_MUSIC_MAINMENU: 1566693136,
    PLAY_MUSIC_MAINMENU_NONSTREAMING: 2016535972,
    PLAY_UI_ABILITYCRAFTING_ADDSELECTION: 3328880489,
    PLAY_UI_ABILITYCRAFTING_BUILD: 439208252,
    PLAY_UI_ABILITYCRAFTING_RESET: 333373105,
    PLAY_UI_ABILITYCRAFTING_SIDEPANEL_OPEN: 4067498624,
    PLAY_UI_MENU_BANESELECT: 1130460745,
    PLAY_UI_MENU_BOONSELECT: 2287968267,
    PLAY_UI_MENU_CHARACTERSELECT_CHANGE: 717266053,
    PLAY_UI_MENU_CREATENEWCHARACTER: 3297311746,
    PLAY_UI_MENU_GENERALCONFIRM: 2296489069,
    PLAY_UI_MENU_GENERICSELECT: 1269450944,
    PLAY_UI_MENU_PREVIEWREALM_ARTHURIAN: 2597327729,
    PLAY_UI_MENU_PREVIEWREALM_TDD: 2163332253,
    PLAY_UI_MENU_PREVIEWREALM_VIKING: 1207032825,
    PLAY_UI_MENU_SELECTREALM: 1614781358,
    PLAY_UI_MENU_SERVERSELECT: 74904892,
    PLAY_UI_MENUSTATE_CLOSED: 2308888328,
    PLAY_UI_MENUSTATE_OPEN: 289315552,
    PLAY_UI_SPELLBOOK_DELETESPELL: 3786236384,
    PLAY_UI_SPELLBOOK_OPEN: 1609015167,
    PLAY_UI_SPELLBOOK_PAGEFLIP_BACKWARD: 1616279629,
    PLAY_UI_SPELLBOOK_PAGEFLIP_FORWARD: 3040087245,
    PLAY_UI_SPELLBOOK_PUTAWAY: 1698649672,
    SET_STATE_CHARACTERCREATION_ATTRIBUTES: 2608939446,
    SET_STATE_CHARACTERCREATION_BOONSANDBANES: 2071975808,
    SET_STATE_CHARACTERCREATION_PREVIEW_ARTHURIAN: 978064922,
    SET_STATE_CHARACTERCREATION_PREVIEW_TDD: 1706995430,
    SET_STATE_CHARACTERCREATION_PREVIEW_VIKING: 2667493300,
    SET_STATE_CHARACTERCREATION_RACE: 501831174,
    SET_STATE_CHARACTERCREATION_SERVERSELECT: 1614103636,
    STOP_UI_MENU_PREVIEWREALM: 997902358,
};
var AbilityTags;
(function (AbilityTags) {
    AbilityTags[AbilityTags["SYSTEM"] = 0] = "SYSTEM";
    AbilityTags[AbilityTags["NonAggressive"] = 1] = "NonAggressive";
    AbilityTags[AbilityTags["NonInteractable"] = 2] = "NonInteractable";
    // Non-elemental
    AbilityTags[AbilityTags["NoMagic"] = 3] = "NoMagic";
    // Physical types
    AbilityTags[AbilityTags["Weapon"] = 4] = "Weapon";
    AbilityTags[AbilityTags["Style"] = 5] = "Style";
    AbilityTags[AbilityTags["Speed"] = 6] = "Speed";
    AbilityTags[AbilityTags["Potential"] = 7] = "Potential";
    AbilityTags[AbilityTags["Targeting"] = 8] = "Targeting";
    // Vocal
    AbilityTags[AbilityTags["Voice"] = 9] = "Voice";
    AbilityTags[AbilityTags["Shout"] = 10] = "Shout";
    AbilityTags[AbilityTags["Inflection"] = 11] = "Inflection";
    // Primary elemental magics
    AbilityTags[AbilityTags["Air"] = 12] = "Air";
    AbilityTags[AbilityTags["Earth"] = 13] = "Earth";
    AbilityTags[AbilityTags["Fire"] = 14] = "Fire";
    AbilityTags[AbilityTags["Water"] = 15] = "Water";
    // Secondary elemental magics
    AbilityTags[AbilityTags["Blast"] = 16] = "Blast";
    AbilityTags[AbilityTags["Lava"] = 17] = "Lava";
    AbilityTags[AbilityTags["Mud"] = 18] = "Mud";
    AbilityTags[AbilityTags["Sand"] = 19] = "Sand";
    AbilityTags[AbilityTags["Steam"] = 20] = "Steam";
    AbilityTags[AbilityTags["Spray"] = 21] = "Spray";
    // Non-elemental magics
    AbilityTags[AbilityTags["Healing"] = 22] = "Healing";
    AbilityTags[AbilityTags["Restoration"] = 23] = "Restoration";
    AbilityTags[AbilityTags["Lifedrain"] = 24] = "Lifedrain";
    AbilityTags[AbilityTags["Swiftness"] = 25] = "Swiftness";
    AbilityTags[AbilityTags["Displacement"] = 26] = "Displacement";
    // Shape
    AbilityTags[AbilityTags["Self"] = 27] = "Self";
    AbilityTags[AbilityTags["Direct"] = 28] = "Direct";
    AbilityTags[AbilityTags["Touch"] = 29] = "Touch";
    AbilityTags[AbilityTags["Dart"] = 30] = "Dart";
    AbilityTags[AbilityTags["Ball"] = 31] = "Ball";
    AbilityTags[AbilityTags["Cloud"] = 32] = "Cloud";
    AbilityTags[AbilityTags["Fountain"] = 33] = "Fountain";
    AbilityTags[AbilityTags["Wall"] = 34] = "Wall";
    AbilityTags[AbilityTags["Field"] = 35] = "Field";
    AbilityTags[AbilityTags["Wave"] = 36] = "Wave";
    AbilityTags[AbilityTags["Pool"] = 37] = "Pool";
    AbilityTags[AbilityTags["Cone"] = 38] = "Cone";
    // Meta types
    AbilityTags[AbilityTags["Rune"] = 39] = "Rune";
    AbilityTags[AbilityTags["Shape"] = 40] = "Shape";
    AbilityTags[AbilityTags["Range"] = 41] = "Range";
    AbilityTags[AbilityTags["Size"] = 42] = "Size";
    AbilityTags[AbilityTags["Infusion"] = 43] = "Infusion";
    AbilityTags[AbilityTags["Focus"] = 44] = "Focus";
    // Combat tags
    AbilityTags[AbilityTags["Blocking"] = 45] = "Blocking";
    AbilityTags[AbilityTags["CounterAttack"] = 46] = "CounterAttack";
    AbilityTags[AbilityTags["Unblockable"] = 47] = "Unblockable";
    // Bens test tags
    AbilityTags[AbilityTags["TestTagA"] = 48] = "TestTagA";
    AbilityTags[AbilityTags["TestTagB"] = 49] = "TestTagB";
    AbilityTags[AbilityTags["TestTagC"] = 50] = "TestTagC";
    AbilityTags[AbilityTags["TestTagD"] = 51] = "TestTagD";
    AbilityTags[AbilityTags["TestTagE"] = 52] = "TestTagE";
    AbilityTags[AbilityTags["COUNT"] = 53] = "COUNT"; // Total number of tags.  Do not use as a tag.
})(AbilityTags || (AbilityTags = {}));
var TagConstraintType;
(function (TagConstraintType) {
    TagConstraintType[TagConstraintType["AllOf"] = 0] = "AllOf";
    TagConstraintType[TagConstraintType["AnyOf"] = 1] = "AnyOf";
    TagConstraintType[TagConstraintType["NoneOf"] = 2] = "NoneOf";
})(TagConstraintType || (TagConstraintType = {}));
var Ability = (function () {
    function Ability(cu) {
        this.cu = cu;
        this.cooldowns = [];
        this.buttons = [];
        this.awaitingUpdate = null;
        this.startWorldTime = -1.0;
        this.triggerWorldTime = -1.0;
    }
    Ability.prototype.MakeButton = function (index) {
        var button = new AbilityButton(this, this.cu, index);
        this.buttons.push(button);
        return button;
    };
    Ability.prototype.Perform = function () {
        if (this.cu.gameClientReady) {
            this.cu.gameClient.Attack(this.id);
        }
    };
    Ability.prototype.UpdateButtons = function () {
        for (var i = 0, len = this.buttons.length; i < len; ++i) {
            var b = this.buttons[i];
            b.UpdateVisuals();
        }
    };
    Ability.prototype.HandleCooldownChanged = function (c) {
        if (!this.CurrentlyRunning())
            this.UpdateButtons();
    };
    Ability.prototype.SetAsActive = function (startTime, triggerTime) {
        if (triggerTime < 0.0)
            triggerTime = startTime + this.triggerTimeOffset;
        if (startTime != this.startWorldTime || triggerTime != this.triggerWorldTime) {
            this.startWorldTime = startTime;
            this.triggerWorldTime = triggerTime;
            this.endWorldTime = triggerTime + this.duration - this.triggerTimeOffset;
            this.UpdateButtons();
        }
    };
    Ability.prototype.ClearAsActive = function () {
        this.SetAsActive(-1, -1);
    };
    Ability.prototype.CurrentlyRunning = function () {
        return this.startWorldTime > 0.0 &&
            this.triggerWorldTime >= this.startWorldTime &&
            this.triggerWorldTime + (this.duration - this.triggerTimeOffset) > this.cu.ServerTime();
    };
    Ability.prototype.OnCooldown = function () {
        for (var i = 0, len = this.cooldowns.length; i < len; ++i) {
            var c = this.cooldowns[i];
            if (c.Active())
                return true;
        }
        return false;
    };
    Ability.prototype.CooldownTimeLeft = function () {
        var result = 0.0;
        for (var i = 0, len = this.cooldowns.length; i < len; ++i) {
            var c = this.cooldowns[i];
            if (c.duration > 0.0) {
                var t = this.cu.ServerTime() - (c.startTime + c.duration);
                if (t > result)
                    result = t;
            }
        }
        return result;
    };
    return Ability;
})();
var CooldownGroup = (function () {
    function CooldownGroup(id, cu) {
        this.id = id;
        this.cu = cu;
        this.abilities = [];
        this.duration = 0.0;
    }
    CooldownGroup.prototype.Active = function () {
        return this.duration > 0.0 && this.startTime + this.duration > this.cu.ServerTime();
    };
    CooldownGroup.prototype.Set = function (newStart, newDuration) {
        if (newStart === this.startTime && newDuration === this.duration)
            return;
        var wasActive = this.Active();
        this.startTime = newStart;
        this.duration = newDuration;
        if (wasActive || this.Active()) {
            for (var i = 0, len = this.abilities.length; i < len; ++i) {
                var a = this.abilities[i];
                a.HandleCooldownChanged(this);
            }
        }
    };
    return CooldownGroup;
})();
var AbilityButton = (function () {
    function AbilityButton(ability, cu, index) {
        this.ability = ability;
        this.cu = cu;
        this.index = index;
        this.activeStartTime = -1;
        this.activeOverlay = null;
        this.cooldownOverlay = null;
        this.rootElement = $('<div/>').addClass('abilityButton').attr('data-id', ability.id).mousedown(function () { return ability.Perform(); });
        this.rootElement.append($('<img/>').addClass('activeHighlight').attr('src', '../images/skillbar/active-frame.gif'));
        this.rootElement.append($('<img/>').addClass('abilityIcon').attr('src', ability.icon));
        this.rootElement.append($('<img/>').addClass('queuedIcon').attr('src', '../images/skillbar/queued-frame.png'));
        var $key = $('<span>').addClass('key').appendTo(this.rootElement);
        var keyBindName = 'Ability ' + (index + 1);
        cu.GetConfigVar(keyBindName);
        cu.Listen('HandleReceiveConfigVar', function (configVar) {
            if (configVar && configVar.hasOwnProperty(keyBindName)) {
                var key = KeyCode.dxKeyCodeMap[configVar[keyBindName]];
                if (key) {
                    $key.text(key);
                }
            }
        });
        cu.Listen('HandleSavedConfigChanges', function () {
            cu.GetConfigVar(keyBindName);
        });
        this.UpdateVisuals();
    }
    AbilityButton.prototype.Remove = function () {
        var index = this.ability.buttons.indexOf(this);
        if (index >= 0) {
            this.ability.buttons.splice(index, 1);
        }
        this.rootElement.detach();
    };
    AbilityButton.prototype.UpdateVisuals = function () {
        var _this = this;
        if (this.cooldownOverlay) {
            this.cooldownOverlay.detach();
            this.cooldownOverlay = null;
        }
        this.rootElement.attr('queued', this.cu.queuedAbility === this.ability ? 1 : 0);
        if (this.ability.CurrentlyRunning()) {
            if (Math.abs(this.activeStartTime - this.ability.startWorldTime) > 0.1) {
                this.activeStartTime = this.ability.startWorldTime;
                window.setTimeout(function () { return _this.UpdateVisuals(); }, 1000 * (this.ability.endWorldTime - this.cu.ServerTime()) + 17);
            }
            this.rootElement.attr('running', 1);
            this.rootElement.attr('cooldown', 0);
            return; // bail and don't apply cooldowns if we're running
        }
        else {
            if (this.activeOverlay) {
                this.activeOverlay.detach();
                this.activeOverlay = null;
            }
            this.rootElement.attr('running', 0);
            this.activeStartTime = -1;
        }
        var cooldown = null;
        for (var i = 0, len = this.ability.cooldowns.length; i < len; ++i) {
            var c = this.ability.cooldowns[i];
            if (c.Active() && (!cooldown || c.duration > cooldown.duration)) {
                cooldown = c;
            }
        }
        if (cooldown) {
            var frac = (this.cu.ServerTime() - cooldown.startTime) / cooldown.duration;
            var timeLeft = (1.0 - frac) * cooldown.duration;
            if (timeLeft > 0.02) {
                if (!this.cooldownOverlay) {
                    this.cooldownOverlay = $('<div>').addClass('cooldownRoot').appendTo(this.rootElement);
                }
                var slide = $('<div>').addClass('cooldownSlide').css('height', Math.round(frac * 100.0) + '%').appendTo(this.cooldownOverlay);
                slide.animate({ height: '100%' }, timeLeft * 1000.0, 'linear', function () { return _this.UpdateVisuals(); });
            }
        }
        this.rootElement.attr('cooldown', (cooldown ? 1 : 0));
    };
    return AbilityButton;
})();
var CallbackSet = (function () {
    function CallbackSet(prefix) {
        this.prefix = prefix;
        this.nextKey = 0;
    }
    CallbackSet.prototype.AddCallback = function (callback, oneTimeOnly) {
        var key = this.prefix + ++this.nextKey;
        if (callback) {
            this[key] = { func: callback, once: oneTimeOnly };
        }
        return key;
    };
    CallbackSet.prototype.CancelCallback = function (key) {
        if (this.hasOwnProperty(key) && key != 'prefix' && key != 'nextKey') {
            delete this[key];
        }
    };
    CallbackSet.prototype.InvokeCallbacks = function () {
        for (var key in this) {
            if (this.hasOwnProperty(key) && key != 'prefix' && key != 'nextKey') {
                var c = this[key];
                c.func();
                if (c.once) {
                    delete this[key];
                }
            }
        }
    };
    return CallbackSet;
})();
var XmppMessageType;
(function (XmppMessageType) {
    XmppMessageType[XmppMessageType["NORMAL"] = -1] = "NORMAL";
    XmppMessageType[XmppMessageType["ERROR"] = 0] = "ERROR";
    XmppMessageType[XmppMessageType["CHAT"] = 1] = "CHAT";
    XmppMessageType[XmppMessageType["GROUPCHAT"] = 2] = "GROUPCHAT";
    XmppMessageType[XmppMessageType["HEADLINE"] = 3] = "HEADLINE";
})(XmppMessageType || (XmppMessageType = {}));
var XmppRoomStatus;
(function (XmppRoomStatus) {
    XmppRoomStatus[XmppRoomStatus["UNKNOWN"] = -1] = "UNKNOWN";
    XmppRoomStatus[XmppRoomStatus["NON_ANONYMOUS_JOIN"] = 100] = "NON_ANONYMOUS_JOIN";
    XmppRoomStatus[XmppRoomStatus["AFILLIATION_CHANGE"] = 101] = "AFILLIATION_CHANGE";
    XmppRoomStatus[XmppRoomStatus["SHOW_UNAVAILABLE"] = 102] = "SHOW_UNAVAILABLE";
    XmppRoomStatus[XmppRoomStatus["NO_SHOW_UNAVAILABLE"] = 103] = "NO_SHOW_UNAVAILABLE";
    XmppRoomStatus[XmppRoomStatus["PRIVACY_CHANGE"] = 104] = "PRIVACY_CHANGE";
    XmppRoomStatus[XmppRoomStatus["SELF"] = 110] = "SELF";
    XmppRoomStatus[XmppRoomStatus["LOGGING_ENABLED"] = 170] = "LOGGING_ENABLED";
    XmppRoomStatus[XmppRoomStatus["LOGGING_DISABLED"] = 171] = "LOGGING_DISABLED";
    XmppRoomStatus[XmppRoomStatus["NON_ANONYMOUS"] = 172] = "NON_ANONYMOUS";
    XmppRoomStatus[XmppRoomStatus["SEMI_ANONYMOUS"] = 173] = "SEMI_ANONYMOUS";
    XmppRoomStatus[XmppRoomStatus["ANONYMOUS"] = 174] = "ANONYMOUS";
    XmppRoomStatus[XmppRoomStatus["CREATED"] = 201] = "CREATED";
    XmppRoomStatus[XmppRoomStatus["NICK_CHANGED"] = 210] = "NICK_CHANGED";
    XmppRoomStatus[XmppRoomStatus["BANNED"] = 301] = "BANNED";
    XmppRoomStatus[XmppRoomStatus["NEW_NICK"] = 303] = "NEW_NICK";
    XmppRoomStatus[XmppRoomStatus["KICKED"] = 307] = "KICKED";
    XmppRoomStatus[XmppRoomStatus["REMOVED_AFFILIATION"] = 321] = "REMOVED_AFFILIATION";
    XmppRoomStatus[XmppRoomStatus["REMOVED_NONMEMBER"] = 322] = "REMOVED_NONMEMBER";
    XmppRoomStatus[XmppRoomStatus["REMOVED_SHUTDOWN"] = 332] = "REMOVED_SHUTDOWN";
})(XmppRoomStatus || (XmppRoomStatus = {}));
var XmppAuthMechanism;
(function (XmppAuthMechanism) {
    XmppAuthMechanism[XmppAuthMechanism["PLAIN"] = 0] = "PLAIN";
    XmppAuthMechanism[XmppAuthMechanism["CSELOGINTOKEN"] = 1] = "CSELOGINTOKEN";
})(XmppAuthMechanism || (XmppAuthMechanism = {}));
// These are the tags needed by the C++ Layer to know which build variables to send to the window.
var Tags;
(function (Tags) {
    Tags[Tags["KEYBIND"] = 2] = "KEYBIND";
    Tags[Tags["INPUT"] = 6] = "INPUT";
    Tags[Tags["AUDIO"] = 8] = "AUDIO";
})(Tags || (Tags = {}));
// This determines which mode of building the UI is currently in.
var BuildUIMode;
(function (BuildUIMode) {
    BuildUIMode[BuildUIMode["NotBuilding"] = 0] = "NotBuilding";
    BuildUIMode[BuildUIMode["PlacingPhantom"] = 1] = "PlacingPhantom";
    BuildUIMode[BuildUIMode["PhantomPlaced"] = 2] = "PhantomPlaced";
    BuildUIMode[BuildUIMode["SelectingBlock"] = 4] = "SelectingBlock";
    BuildUIMode[BuildUIMode["BlockSelected"] = 8] = "BlockSelected";
})(BuildUIMode || (BuildUIMode = {}));
var KeyCode = {
    getKeyCodeFromEvent: function (e) {
        var keycode = null;
        if (window.event) {
            keycode = window.event.keyCode;
        }
        else if (e) {
            keycode = e.which;
        }
        return keycode;
    },
    getKeyCodeValueFromEvent: function (e) {
        var keycode = KeyCode.getKeyCodeFromEvent(e);
        if (keycode) {
            return KeyCode.jsKeyCodeMap[keycode];
        }
        return null;
    },
    dxKeyCodeMap: {
        0x01: 'ESCAPE',
        0x02: '1',
        0x03: '2',
        0x04: '3',
        0x05: '4',
        0x06: '5',
        0x07: '6',
        0x08: '7',
        0x0B: '0',
        0x0C: '-',
        0x0D: '=',
        0x0E: 'BACK',
        0x0F: 'TAB',
        0x10: 'Q',
        0x11: 'W',
        0x12: 'E',
        0x15: 'Y',
        0x16: 'U',
        0x17: 'I',
        0x18: 'O',
        0x19: 'P',
        0x1A: 'LBRACKET',
        0x1B: 'RBRACKET',
        0x1C: 'RETURN',
        0x1D: 'CONTROL',
        0x1E: 'A',
        0x1F: 'S',
        0x20: 'D',
        0x21: 'F',
        0x22: 'G',
        0x23: 'H',
        0x24: 'J',
        0x27: 'SEMICOLON',
        0x28: 'APOSTROPHE',
        0x29: '`',
        0x2A: 'SHIFT',
        0x2B: 'BACKSLASH',
        0x2C: 'Z',
        0x2D: 'X',
        0x14: 'T',
        0x2E: 'C',
        0x2F: 'V',
        0x30: 'B',
        0x31: 'N',
        0x32: 'M',
        0x33: 'COMMA',
        0x34: 'PERIOD',
        0x35: 'SLASH',
        0x37: 'MULTIPLY',
        0x38: 'ALT',
        0x39: 'SPACE',
        0x3A: 'CAPITAL',
        0x3B: 'F1',
        0x3C: 'F2',
        0x3D: 'F3',
        0x3E: 'F4',
        0x3F: 'F5',
        0x40: 'F6',
        0x41: 'F7',
        0x42: 'F8',
        0x43: 'F9',
        0x44: 'F10',
        0x45: 'NUMLOCK',
        0x46: 'SCROLL',
        0x48: 'NUMPAD8',
        0x49: 'NUMPAD9',
        0x4A: 'SUBTRACT',
        0x4B: 'NUMPAD4',
        0x4C: 'NUMPAD5',
        0x4D: 'NUMPAD6',
        0x4E: 'ADD',
        0xDC: 'RWIN',
        0x4F: 'NUMPAD1',
        0x50: 'NUMPAD2',
        0x51: 'NUMPAD3',
        0x52: 'NUMPAD0',
        0x53: 'DECIMAL',
        0x56: 'OEM_102',
        0x57: 'F11',
        0x47: 'NUMPAD7',
        0x58: 'F12',
        0x64: 'F13',
        0x65: 'F14',
        0x66: 'F15',
        0x70: 'KANA',
        0x73: 'ABNT_C1',
        0x79: 'CONVERT',
        0x7B: 'NOCONVERT',
        0x7D: 'YEN',
        0x7E: 'ABNT_C2',
        0x8D: 'NUMPADEQUALS',
        0x90: 'PREVTRACK',
        0x91: 'AT',
        0x92: 'COLON',
        0x93: 'UNDERLINE',
        0x36: 'SHIFT',
        0x94: 'KANJI',
        0x95: 'STOP',
        0x96: 'AX',
        0x97: 'UNLABELED',
        0x99: 'NEXTTRACK',
        0x9C: 'NUMPADENTER',
        0x9D: 'CONTROL',
        0x26: 'L',
        0xA0: 'MUTE',
        0xA1: 'CALCULATOR',
        0xA2: 'PLAYPAUSE',
        0xA4: 'MEDIASTOP',
        0xAE: 'VOLUMEDOWN',
        0xB0: 'VOLUMEUP',
        0xB2: 'WEBHOME',
        0x25: 'K',
        0xB3: 'NUMPADCOMMA',
        0xB5: 'DIVIDE',
        0xB7: 'SYSRQ',
        0xB8: 'ALT',
        0xC5: 'PAUSE',
        0xC7: 'HOME ',
        0xC8: 'UP',
        0xC9: 'PAGEUP',
        0xCB: 'LEFT',
        0xCD: 'RIGHT',
        0xCF: 'END',
        0xD0: 'DOWN',
        0xD1: 'PAGEDN',
        0xD2: 'INSERT',
        0xD3: 'DELETE',
        0xDB: 'LWIN',
        0xDD: 'APPS',
        0xDE: 'POWER',
        0xDF: 'SLEEP',
        0xE3: 'WAKE',
        0xE5: 'WEBSEARCH',
        0xE6: 'WEBFAVORITES',
        0xE7: 'WEBREFRESH',
        0xE8: 'WEBSTOP',
        0xE9: 'WEBFORWARD',
        0xEA: 'WEBBACK',
        0xEB: 'MYCOMPUTER',
        0xEC: 'MAIL',
        0xED: 'MEDIASELECT',
        0x09: '8',
        0x13: 'R',
        0x0A: '9',
    },
    jsKeyCodeMap: {
        8: 0x0E,
        9: 0x0F,
        13: 0x1C,
        16: 0x2A | 0x36,
        17: 0x1D | 0x9D,
        18: 0x38 | 0xB8,
        19: 0xC5,
        20: 0x3A,
        27: 0x01,
        32: 0x39,
        33: 0xC9,
        34: 0xD1,
        35: 0xCF,
        36: 0xC7,
        37: 0xCB,
        38: 0xC8,
        39: 0xCD,
        40: 0xD0,
        //PRINT_SCREEN: 44,
        45: 0xD2,
        46: 0xD3,
        //0 - 9
        48: 0x0B,
        49: 0x02,
        50: 0x03,
        51: 0x04,
        52: 0x05,
        53: 0x06,
        54: 0x07,
        55: 0x08,
        56: 0x09,
        57: 0x0A,
        //A - Z
        65: 0x1E,
        66: 0x30,
        67: 0x2E,
        68: 0x20,
        69: 0x12,
        70: 0x21,
        71: 0x22,
        72: 0x23,
        73: 0x17,
        74: 0x24,
        75: 0x25,
        76: 0x26,
        77: 0x32,
        78: 0x31,
        79: 0x18,
        80: 0x19,
        81: 0x10,
        82: 0x13,
        83: 0x1F,
        84: 0x14,
        85: 0x16,
        86: 0x2F,
        87: 0x11,
        88: 0x2D,
        89: 0x15,
        90: 0x2C,
        91: 0xDB,
        92: 0xDC,
        //CONTEXT_MENU: 93,
        // NUMPAD0-9
        96: 0x52,
        97: 0x4F,
        98: 0x50,
        99: 0x51,
        100: 0x4B,
        101: 0x4C,
        102: 0x4D,
        103: 0x47,
        104: 0x48,
        105: 0x49,
        // NUMPAD special keys
        106: 0x37,
        107: 0x4E,
        109: 0x4A,
        110: 0x53,
        111: 0xB5,
        // f1-f12
        112: 0x3B,
        113: 0x3C,
        114: 0x3D,
        115: 0x3E,
        116: 0x3F,
        117: 0x40,
        118: 0x41,
        119: 0x42,
        120: 0x43,
        121: 0x44,
        122: 0x57,
        123: 0x58,
        144: 0x45,
        145: 0x46,
        // OS-specific media keys like volume controls and browser controls.
        0xA6: 0xEA,
        0xA7: 0xE9,
        0xA8: 0xE7,
        0xA9: 0xE8,
        0xAA: 0xE5,
        0xAB: 0xE6,
        0xAC: 0xB2,
        0xAD: 0xA0,
        0xAE: 0xAE,
        0xAF: 0xB0,
        0xB0: 0x99,
        0xB1: 0x90,
        0xB2: 0xA4,
        0xB3: 0xA2,
        0xB4: 0xEC,
        0xB5: 0xED,
        //    0xB6: ????, // Start Application 1 key
        //    0xB7: ????, // Start Application 2 key
        186: 0x27,
        189: 0x0C,
        187: 0x0D,
        188: 0x33,
        190: 0x34,
        191: 0x35,
        192: 0x28,
        219: 0x1A,
        220: 0x2B,
        221: 0x1B,
        222: undefined,
        223: 0x29,
    },
    jsModifiedByShift: {
        192: '~',
        48: ')',
        49: '!',
        50: '@',
        51: '#',
        52: '$',
        53: '%',
        54: '^',
        55: '&',
        56: '*',
        57: '(',
        109: '_',
        61: '+',
        219: '{',
        221: '}',
        220: '|',
        59: ':',
        222: '\'',
        188: '<',
        189: '>',
        191: '?',
        96: 'insert',
        97: 'end',
        98: 'down',
        99: 'pagedown',
        100: 'left',
        102: 'right',
        103: 'home',
        104: 'up',
        105: 'pageup'
    }
};
var JID = (function () {
    function JID(unparsed) {
        this.user = '';
        this.domain = '';
        this.resource = '';
        // JIDs should be in the format of user@domain/resource (tim@cse.com/Trillian)
        var chopped = unparsed.split(/[@]/);
        if (chopped.length == 0)
            return;
        if (chopped.length == 1) {
            this.domain = chopped[0];
        }
        else if (chopped.length > 1) {
            this.user = chopped[0];
            chopped = chopped[1].split(/[\/]/);
            if (chopped.length > 0)
                this.domain = chopped[0];
            if (chopped.length > 1)
                this.resource = chopped[1];
        }
    }
    JID.prototype.HasUser = function () {
        return this.user && this.user !== '';
    };
    JID.prototype.HasDomain = function () {
        return this.domain && this.domain !== '';
    };
    JID.prototype.HasResource = function () {
        return this.resource && this.resource !== '';
    };
    JID.prototype.EnsureHasUser = function () {
        if (!this.HasUser())
            throw new Error('jid user required');
    };
    JID.prototype.EnsureHasDomain = function () {
        if (!this.HasDomain())
            throw new Error('jid domain required');
    };
    JID.prototype.EnsureHasResource = function () {
        if (!this.HasResource())
            throw new Error('jid resource required');
    };
    return JID;
})();
var CU = (function () {
    function CU(initCallback, connectedCallback) {
        var _this = this;
        /* Begin Constants */
        this.CHAT_DOMAIN = 'chat.camelotunchained.com';
        this.CHAT_SERVICE = 'conference.' + this.CHAT_DOMAIN;
        this.GLOBAL_CHATROOM_NAME = '_global';
        this.COMBAT_CHATROOM_NAME = '_combat';
        this.CUBE_CHATROOM_NAME = '_cube';
        this.GLOBAL_CHATROOM = this.GLOBAL_CHATROOM_NAME + '@' + this.CHAT_SERVICE;
        this.COMBAT_CHATROOM = this.COMBAT_CHATROOM_NAME + '@' + this.CHAT_SERVICE;
        this.CUBE_CHATROOM = this.CUBE_CHATROOM_NAME + '@' + this.CHAT_SERVICE;
        this.WEB_API_HOST = 'chat.camelotunchained.com';
        this.WEB_API_PORT = 8000;
        this.CHAT_API_PORT = 8222;
        this.XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl';
        this.XMPP_BIND = 'urn:ietf:params:xml:ns:xmpp-bind';
        this.SOUND_EVENTS = SoundEvents;
        // matches Emote enum in AnimatableInterface.h
        this.Emote = {
            Dance1: 0,
            Dance2: 1,
            Wave1: 2,
            Wave2: 3,
            // Always last and not counted in EMOTE_COUNT
            Stop: 4,
            None: 5
        };
        /* End Constants */
        /* Begin Variables */
        this.ready = false;
        this.gameClient = null;
        this.gameClientReady = false;
        this.forceWebSocketChat = false;
        this.onInit = new CallbackSet('onInit');
        this.listeners = {};
        this.webSocket = null;
        this.idCounter = 0;
        this.isAuthed = false;
        this.isBound = false;
        this.currentJid = null;
        this.roomSelfPresences = [];
        this.timeStarted = Date.now();
        this.gameServerURL = null;
        this.onServerConnected = new CallbackSet('onServerConnected');
        this.abilities = {};
        this.cooldowns = {};
        this.currentAbility = null;
        this.queuedAbility = null;
        this.OnInitialized(initCallback);
        this.OnServerConnected(connectedCallback);
        if (this.HasAPI()) {
            this.gameClient = cuAPI;
            var myCallback = function () {
                _this.ready = true;
                _this.gameClientReady = true;
                if (_.isFunction(_this.gameClient.OnAbilityCooldown)) {
                    _this.gameClient.OnAbilityCooldown(function (c, t, d) { return _this.HandleAbilityCooldown(c, t, d); });
                }
                if (_.isFunction(_this.gameClient.OnAbilityActive)) {
                    _this.gameClient.OnAbilityActive(function (curr, start, trigger, queue) {
                        if (curr)
                            curr = parseInt(curr, 16).toString(16);
                        if (queue)
                            queue = parseInt(queue, 16).toString(16);
                        _this.HandleAbilityActive((curr ? cu.abilities[curr] : null), start, trigger, (queue ? cu.abilities[queue] : null));
                    });
                }
                if (_.isFunction(_this.gameClient.OnAbilityError)) {
                    _this.gameClient.OnAbilityError(function (message) { return _this.Fire('HandleAbilityError', message); });
                }
                if (_.isFunction(_this.gameClient.OnReceiveConfigVars)) {
                    _this.gameClient.OnReceiveConfigVars(function (configs) { return _this.Fire('HandleReceiveConfigVars', configs); });
                }
                if (_.isFunction(_this.gameClient.OnReceiveConfigVar)) {
                    _this.gameClient.OnReceiveConfigVar(function (config) { return _this.Fire('HandleReceiveConfigVar', config); });
                }
                if (_.isFunction(_this.gameClient.OnConfigVarChanged)) {
                    _this.gameClient.OnConfigVarChanged(function (isChangeSuccessful) { return _this.Fire('HandleConfigVarChanged', isChangeSuccessful); });
                }
                if (_.isFunction(_this.gameClient.OnSavedConfigChanges)) {
                    _this.gameClient.OnSavedConfigChanges(function () { return _this.Fire('HandleSavedConfigChanges'); });
                }
                if (_.isFunction(_this.gameClient.OnBuildingModeChanged)) {
                    _this.gameClient.OnBuildingModeChanged(function (buildingMode) { return _this.Fire('HandleBuildingModeChanged', buildingMode); });
                }
                if (_.isFunction(_this.gameClient.OnReceiveBlocks)) {
                    _this.gameClient.OnReceiveBlocks(function (buildingDict) { return _this.Fire('HandleReceiveBlocks', buildingDict); });
                }
                if (_.isFunction(_this.gameClient.OnReceiveScreenShot)) {
                    _this.gameClient.OnReceiveScreenShot(function (screenShotString) { return _this.Fire('HandleReceiveScreenShot', screenShotString); });
                }
                if (_.isFunction(_this.gameClient.OnReceiveBlockTags)) {
                    _this.gameClient.OnReceiveBlockTags(function (blockID, tagDict) { return _this.Fire('HandleReceiveBlockTags', blockID, tagDict); });
                }
                if (_.isFunction(_this.gameClient.OnCopyBlueprint)) {
                    _this.gameClient.OnCopyBlueprint(function () { return _this.Fire('HandleCopyBlueprint'); });
                }
                if (_.isFunction(_this.gameClient.OnNewBlueprint)) {
                    _this.gameClient.OnNewBlueprint(function (index, name) { return _this.Fire('HandleNewBlueprint', index, name); });
                }
                _this.onInit.InvokeCallbacks();
                _this.gameServerURL = _this.gameClient.serverURL;
                if (_this.gameServerURL) {
                    _this.onServerConnected.InvokeCallbacks();
                }
                else {
                    if (_.isFunction(_this.gameClient.OnServerConnected)) {
                        _this.gameClient.OnServerConnected(function () {
                            _this.gameServerURL = _this.gameClient.serverURL;
                            _this.onServerConnected.InvokeCallbacks();
                        });
                    }
                }
            };
            if (this.gameClient.initialized) {
                myCallback();
            }
            else {
                this.gameClient.OnInitialized(myCallback);
            }
        }
        else {
            var self = this;
            $(function () {
                self.ready = true;
                self.onInit.InvokeCallbacks();
            });
        }
    }
    /* End Variables */
    CU.prototype.OnInitialized = function (c) {
        if (this.ready) {
            c();
        }
        else {
            this.onInit.AddCallback(c, true);
        }
    };
    CU.prototype.HasAPI = function () {
        // ellian return true;
        return typeof cuAPI !== 'undefined';
    };
    CU.prototype.ApiUrl = function (action) {
        // TODO: this also needs to handle checking whether we're connected or not
        if (this.HasAPI())
            return 'cuapi://server/api/' + action;
        return 'http://localhost:8000/api/' + action;
    };
    CU.prototype.ApiHost = function () {
        return this.HasAPI() && cuAPI.webAPIHost ? cuAPI.webAPIHost : 'hatchery.camelotunchained.com';
    };
    CU.prototype.SecureApiUrl = function (action) {
        var host = this.ApiHost();
        var isLocalhost = host === 'localhost';
        var protocol = isLocalhost ? 'http' : 'https';
        var port = isLocalhost ? '8000' : '4443';
        return protocol + '://' + host + ':' + port + '/' + action;
    };
    CU.prototype.InGame = function () {
        return this.gameClient !== null;
    };
    CU.prototype.OnServerConnected = function (c) {
        if (this.gameServerURL) {
            c();
        }
        else {
            this.onServerConnected.AddCallback(c, true);
        }
    };
    CU.prototype.SetDebugServer = function (serverURL) {
        var _this = this;
        if (!this.gameClient) {
            if (!serverURL)
                serverURL = 'http://localhost:8000/api/';
            this.gameServerURL = serverURL;
            this.OnInitialized(function () { return _this.onServerConnected.InvokeCallbacks(); });
        }
    };
    CU.prototype.ServerTime = function () {
        if (this.gameClientReady) {
            return this.gameClient.serverTime;
        }
        else if (this.gameClient) {
            return 0.0;
        }
        else {
            return (Date.now() - this.timeStarted) / 1000.0;
        }
    };
    // Respawn
    CU.prototype.Respawn = function (id) {
        if (this.InGame()) {
            this.gameClient.Respawn(id);
        }
    };
    CU.prototype.HandleAbilityCooldown = function (cooldownID, timeStarted, duration) {
        var c = this.cooldowns[cooldownID];
        if (!c) {
            this.cooldowns[cooldownID] = c = new CooldownGroup(cooldownID, this);
        }
        c.Set(timeStarted, duration);
    };
    CU.prototype.RequestAbility = function (id, callback, force) {
        var _this = this;
        var current = this.abilities[id];
        if (current && !current.awaitingUpdate && !force) {
            callback(current);
        }
        else {
            if (!current) {
                current = this.abilities[id] = new Ability(this);
                current.id = id;
            }
            if (!current.awaitingUpdate) {
                current.awaitingUpdate = [callback];
            }
            else {
                current.awaitingUpdate.push(callback);
            }
            $.getJSON('http://' + this.ApiHost() + ':8000/api/abilities/' + parseInt(id, 16), function (data) { return _this.UpdateAbility(data); });
        }
    };
    CU.prototype.RequestAllAbilities = function (loginToken, characterID, callback) {
        if (!loginToken || !characterID)
            return null;
        if (!this.allAbilitiesCallback) {
            this.allAbilitiesCallback = [callback];
            return $.getJSON('http://hatchery.camelotunchained.com:8000/api/abilities');
        }
        else {
            this.allAbilitiesCallback.push(callback);
        }
    };
    CU.prototype.UpdateAbility = function (rawAbility) {
        var a = new Ability(this);
        a.id = parseInt(rawAbility.id, 16).toString(16);
        a.icon = rawAbility.icon;
        if (rawAbility.cooldowns) {
            for (var i = 0; i < rawAbility.cooldowns.length; ++i) {
                var cooldownID = rawAbility.cooldowns[i];
                var c = this.cooldowns[cooldownID];
                if (!c) {
                    this.cooldowns[cooldownID] = c = new CooldownGroup(cooldownID, this);
                }
                if (a.cooldowns.indexOf(c) === -1) {
                    c.abilities.push(a);
                    a.cooldowns.push(c);
                }
            }
        }
        a.duration = rawAbility.duration;
        a.triggerTimeOffset = rawAbility.triggerTime;
        a.name = rawAbility.name;
        a.tooltip = rawAbility.tooltip;
        var old = this.abilities[a.id];
        this.abilities[a.id] = a;
        if (old) {
            for (var i = 0; i < old.cooldowns.length; ++i) {
                var index = old.cooldowns[i].abilities.indexOf(old);
                if (index >= 0) {
                    old.cooldowns[i].abilities.splice(index, 1);
                }
            }
            a.buttons = old.buttons;
            for (var i = 0; i < a.buttons.length; ++i) {
                a.buttons[i].ability = a;
            }
            a.SetAsActive(old.startWorldTime, old.triggerWorldTime);
            if (old.awaitingUpdate) {
                for (var i = 0; i < old.awaitingUpdate.length; ++i) {
                    old.awaitingUpdate[i](a);
                }
            }
        }
        return a;
    };
    CU.prototype.UpdateAllAbilities = function (rawList) {
        var convertedList = rawList;
        var oldAbilities = $.extend({}, this.abilities);
        for (var i = 0, len = rawList.length; i < len; ++i) {
            var a = convertedList[i] = this.UpdateAbility(rawList[i]);
            delete oldAbilities[a.id];
        }
        for (var id in oldAbilities) {
            delete this.abilities[id];
        }
        if (this.allAbilitiesCallback) {
            for (i = 0, len = this.allAbilitiesCallback.length; i < len; ++i) {
                this.allAbilitiesCallback[i](convertedList);
            }
            this.allAbilitiesCallback = null;
        }
    };
    CU.prototype.HandleAbilityActive = function (current, startTime, triggerTime, queued) {
        var updatedCurrent = false;
        var oldCurrent = this.currentAbility;
        var oldQueued = this.queuedAbility;
        console.log('HandleAbilityActive newCurr=' + (current ? current.id : 'null') + ' oldCurr=' + (oldCurrent ? oldCurrent.id : 'null') + ' newQ=' + (queued ? queued.id : 'null') + ' oldQ=' + (oldQueued ? oldQueued.id : 'null'));
        this.currentAbility = current;
        this.queuedAbility = queued;
        if (current !== oldCurrent ||
            (current && (startTime != current.startWorldTime ||
                triggerTime >= 0.0 && triggerTime != current.triggerWorldTime))) {
            updatedCurrent = true;
            if (current)
                current.SetAsActive(startTime, triggerTime);
            if (oldCurrent && oldCurrent !== current)
                oldCurrent.ClearAsActive();
        }
        if (queued != oldQueued) {
            if (queued && !(updatedCurrent && (queued === current || queued === oldCurrent))) {
                queued.UpdateButtons();
            }
            if (oldQueued && !(updatedCurrent && (oldQueued === current || oldQueued === oldCurrent))) {
                oldQueued.UpdateButtons();
            }
        }
    };
    CU.prototype.RunAtInterval = function (callback, updateFPS) {
        if (updateFPS === void 0) { updateFPS = 5; }
        if (updateFPS > 0) {
            callback();
            return window.setInterval(callback, 1000 / updateFPS);
        }
    };
    CU.prototype.FindElement = function (selector, context) {
        var $element = $(selector, context);
        if (!$element.length)
            throw new Error(selector + ' required');
        return $element;
    };
    CU.prototype.GetConfigVar = function (variable) {
        if (cu.HasAPI()) {
            cuAPI.GetConfigVar(variable);
        }
    };
    CU.prototype.GetConfigVars = function (tag) {
        if (cu.HasAPI()) {
            cuAPI.GetConfigVars(tag);
        }
    };
    CU.prototype.ChangeConfigVar = function (variable, value) {
        if (cu.HasAPI()) {
            cuAPI.ChangeConfigVar(variable, "" + value);
        }
    };
    CU.prototype.CancelChangeConfig = function (variable) {
        if (cu.HasAPI()) {
            cuAPI.CancelChangeConfig(variable);
        }
    };
    CU.prototype.SaveConfigChanges = function () {
        if (cu.HasAPI()) {
            cuAPI.SaveConfigChanges();
        }
    };
    CU.prototype.CancelAllConfigChanges = function (tag) {
        if (cu.HasAPI()) {
            cuAPI.CancelAllConfigChanges(tag);
        }
    };
    CU.prototype.RestoreConfigDefaults = function (tag) {
        if (cu.HasAPI()) {
            cuAPI.RestoreConfigDefaults(tag);
        }
    };
    CU.prototype.ToggleBuildingMode = function () {
        if (cu.HasAPI()) {
            cuAPI.ToggleBuildingMode();
        }
    };
    CU.prototype.SetBuildingMode = function (newMode) {
        if (cu.HasAPI()) {
            cuAPI.SetBuildingMode(newMode);
        }
    };
    CU.prototype.RequestBlocks = function () {
        if (cu.HasAPI()) {
            cuAPI.RequestBlocks();
        }
    };
    CU.prototype.RequestBlockTags = function (blockID) {
        if (cu.HasAPI()) {
            cuAPI.RequestBlockTags(blockID);
        }
    };
    CU.prototype.ChangeBlockType = function (newType) {
        if (cu.HasAPI()) {
            cuAPI.ChangeBlockType(newType);
        }
    };
    CU.prototype.SelectBlueprint = function (index) {
        if (cu.HasAPI()) {
            cuAPI.SelectBlueprint(index);
        }
    };
    CU.prototype.SaveBlueprint = function (name) {
        if (cu.HasAPI()) {
            cuAPI.SaveBlueprint(name);
        }
    };
    CU.prototype.RequestBlueprints = function () {
        if (cu.HasAPI()) {
            cuAPI.RequestBlueprints();
        }
    };
    CU.prototype.CommitBlock = function () {
        if (cu.HasAPI()) {
            cuAPI.CommitBlock();
        }
    };
    CU.prototype.CancelBlockPlacement = function () {
        if (cu.HasAPI()) {
            cuAPI.CancelBlockPlacement();
        }
    };
    CU.prototype.BlockRotateX = function () {
        if (cu.HasAPI()) {
            cuAPI.BlockRotateX();
        }
    };
    CU.prototype.BlockRotateY = function () {
        if (cu.HasAPI()) {
            cuAPI.BlockRotateY();
        }
    };
    CU.prototype.BlockRotateZ = function () {
        if (cu.HasAPI()) {
            cuAPI.BlockRotateZ();
        }
    };
    CU.prototype.RemoveIslands = function () {
        if (cu.HasAPI()) {
            cuAPI.RemoveIslands();
        }
    };
    CU.prototype.ApplyStability = function () {
        if (cu.HasAPI()) {
            cuAPI.ApplyStability();
        }
    };
    CU.prototype.BlockFlipX = function () {
        if (cu.HasAPI()) {
            cuAPI.BlockFlipX();
        }
    };
    CU.prototype.BlockFlipY = function () {
        if (cu.HasAPI()) {
            cuAPI.BlockFlipY();
        }
    };
    CU.prototype.BlockFlipZ = function () {
        if (cu.HasAPI()) {
            cuAPI.BlockFlipZ();
        }
    };
    CU.prototype.CopyBlueprint = function () {
        if (cu.HasAPI()) {
            cuAPI.CopyBlueprint();
        }
    };
    CU.prototype.PasteBlueprint = function () {
        if (cu.HasAPI()) {
            cuAPI.PasteBlueprint();
        }
    };
    CU.prototype.OpenScreenshotShare = function () {
        if (cu.HasAPI()) {
            cuAPI.OpenScreenshotShare();
        }
    };
    CU.prototype.TakeScreenshot = function () {
        if (cu.HasAPI()) {
            cuAPI.TakeScreenshot();
        }
    };
    CU.prototype.Fire = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.listeners.hasOwnProperty(event)) {
            this.listeners[event].forEach(function (listener) {
                listener.apply(this, args);
            });
        }
    };
    CU.prototype.Listen = function (event, callback) {
        if (!this.listeners.hasOwnProperty(event)) {
            this.listeners[event] = [];
        }
        this.listeners[event].push(callback);
    };
    CU.prototype.GetFactionCssClassName = function (factionValue) {
        switch (factionValue) {
            case 3: return 'arthurian';
            case 2: return 'viking';
            case 1: return 'tdd';
            default: return 'factionless';
        }
    };
    CU.prototype.GetFactionName = function (factionValue) {
        switch (factionValue) {
            case 3: return 'Arthurian';
            case 2: return 'Viking';
            case 1: return 'Tuatha De Danann';
            default: return 'Factionless';
        }
    };
    CU.prototype.GetFactionChannel = function (factionValue) {
        switch (factionValue) {
            case 3: return '_arthurian';
            case 2: return '_viking';
            case 1: return '_tuatha';
            default: return null;
        }
    };
    CU.prototype.GetPlayerName = function (player) {
        var name = player.name;
        if (!name)
            this.GetFactionName(player.faction);
        return _.escape(name);
    };
    CU.prototype.JoinMUC = function (room) {
        if (cu.HasAPI()) {
            cuAPI.JoinMUC(room);
        }
    };
    CU.prototype.LeaveMUC = function (room) {
        if (cu.HasAPI()) {
            cuAPI.LeaveMUC(room);
        }
    };
    CU.prototype.SendChat = function (messageType, room, input) {
        if (!cu.forceWebSocketChat && cu.HasAPI()) {
            cuAPI.SendChat(messageType, room, input);
        }
        else {
            this.SendWebSocketChatMessage(messageType, room, input);
        }
    };
    CU.prototype.ConsoleCommand = function (body) {
        if (cu.HasAPI())
            cuAPI.ConsoleCommand(body);
    };
    CU.prototype.RequestInputOwnership = function () {
        if (cu.HasAPI())
            cuAPI.RequestInputOwnership();
    };
    CU.prototype.ReleaseInputOwnership = function () {
        if (cu.HasAPI())
            cuAPI.ReleaseInputOwnership();
    };
    CU.prototype.DestroyWebSocket = function () {
        if (this.webSocket) {
            this.webSocket.close();
            this.webSocket = null;
        }
    };
    CU.prototype.CreateWebSocket = function (loginToken, domain, boundCallback, presenceCallback) {
        var _this = this;
        var self = this;
        if (!loginToken) {
            return null;
        }
        this.webSocket = new WebSocket('ws://' + this.WEB_API_HOST + ':' + this.CHAT_API_PORT + '/api/chat', 'xmpp');
        this.webSocket.onopen = function (e) {
            try {
                console.log('websocket onopen', e);
                // open stream
                self.SendWebSocketMessage(self.$openStream({ hasOpenXmlTag: true, to: domain }));
            }
            catch (e) {
                console.log('websocket error onopen: ' + e.message, e);
            }
        };
        this.webSocket.onmessage = function (e) {
            try {
                var xmlDoc = self.ParseXml(e.data);
                switch (xmlDoc.documentElement.nodeName) {
                    case 'stream:stream':
                        console.log('stream:stream response', xmlDoc.documentElement);
                        break;
                    case 'stream:features':
                        console.log('stream:features response', xmlDoc.documentElement);
                        // close stream when navigating away from page
                        $(window).unload(function () {
                            if (self.HasOpenWebSocket()) {
                                self.SendWebSocketMessage(self.$closeStream());
                            }
                        });
                        var features = xmlDoc.documentElement;
                        if (!self.isAuthed) {
                            var mechanisms = features.getElementsByTagName('mechanism');
                            var hasCseLoginTokenMechanism = false;
                            for (var i = 0, length = mechanisms.length; i < length; i++) {
                                var mechanism = self.GetElementNodeValue(mechanisms[i]);
                                if (mechanism === XmppAuthMechanism[1 /* CSELOGINTOKEN */]) {
                                    hasCseLoginTokenMechanism = true;
                                    break;
                                }
                            }
                            if (hasCseLoginTokenMechanism) {
                                self.SendWebSocketMessage(self.$auth({ loginToken: loginToken, mechanism: XmppAuthMechanism[1 /* CSELOGINTOKEN */] }));
                            }
                        }
                        else {
                            var bind = self.GetFirstElement(features.getElementsByTagName('bind'));
                            if (bind && bind.getAttribute('xmlns') === self.XMPP_BIND) {
                                self.SendWebSocketMessage($iq({ type: 'set', id: self.GetNextId() }).c('bind', { xmlns: self.XMPP_BIND }));
                            }
                        }
                        break;
                    case 'failure':
                        console.log('failure response', xmlDoc.documentElement);
                        var failure = xmlDoc.documentElement;
                        if (failure.getAttribute('xmlns') === _this.XMPP_SASL) {
                            self.isAuthed = false;
                            self.Fire('XmppAuthFailed');
                        }
                        break;
                    case 'success':
                        console.log('success response', xmlDoc.documentElement);
                        var success = xmlDoc.documentElement;
                        if (success.getAttribute('xmlns') === self.XMPP_SASL) {
                            self.isAuthed = true;
                        }
                        if (self.isAuthed) {
                            self.SendWebSocketMessage(self.$openStream({ to: domain }));
                        }
                        break;
                    case 'iq':
                        console.log('iq response', xmlDoc.documentElement);
                        var iq = xmlDoc.documentElement;
                        if (iq.getAttribute('type') === 'result') {
                            var bind = self.GetFirstElement(iq.getElementsByTagName('bind'));
                            if (bind && bind.getAttribute('xmlns') === self.XMPP_BIND) {
                                var jidValue = self.GetFirstElementValue(iq.getElementsByTagName('jid'));
                                if (jidValue) {
                                    var jid = new JID(jidValue);
                                    if (jid.HasUser()) {
                                        self.currentJid = jid;
                                        self.isBound = true;
                                        boundCallback();
                                    }
                                }
                            }
                        }
                        break;
                    case 'presence':
                        console.log('presence response', xmlDoc.documentElement);
                        if (!self.isAuthed || !self.isBound)
                            return;
                        // check if it has finished receiving the room roster
                        var presence = xmlDoc.documentElement;
                        var from = presence.getAttribute('from');
                        if (!from || !from.length) {
                            return;
                        }
                        var x = self.GetFirstElement(presence.getElementsByTagName('x'));
                        if (!x || x.getAttribute('xmlns') !== 'http://jabber.org/protocol/muc#user') {
                            return;
                        }
                        var statuses = x.getElementsByTagName('status');
                        if (!statuses || !statuses.length) {
                            return;
                        }
                        var hasSelfPresence = false;
                        for (var i = 0, length = statuses.length; i < length; i++) {
                            var status = statuses[i];
                            var code = status.getAttribute('code');
                            if (parseInt(code, 10) === XmppRoomStatus.SELF) {
                                var jid = new JID(from);
                                jid.EnsureHasUser();
                                jid.EnsureHasDomain();
                                self.roomSelfPresences.push(jid.user + '@' + jid.domain);
                                hasSelfPresence = true;
                                break;
                            }
                        }
                        if (hasSelfPresence) {
                            presenceCallback();
                            self.Fire('XmppPresenceCompleted');
                        }
                        break;
                    case 'message':
                        console.log('message response', xmlDoc.documentElement);
                        if (!self.isAuthed || !self.isBound)
                            return;
                        var message = xmlDoc.documentElement;
                        var messageType = XmppMessageType[message.getAttribute('type').toUpperCase()];
                        var from = message.getAttribute('from');
                        var body = self.GetFirstElementValue(message.getElementsByTagName('body'));
                        var nick = self.GetFirstElementValue(message.getElementsByTagName('nick'));
                        var cseflags = self.GetFirstElement(message.getElementsByTagName('cseflags'));
                        var isCse = cseflags && cseflags.getAttribute('cse') === 'cse';
                        self.Fire('OnChat', messageType, from, body, nick, isCse);
                        break;
                    default:
                        console.log('websocket unhandled response', xmlDoc.documentElement.nodeName, xmlDoc.documentElement);
                        break;
                }
            }
            catch (e) {
                console.log('websocket onmessage error: ' + e.message, e);
            }
        };
        this.webSocket.onerror = function (e) {
            console.log('websocket onerror: ' + e.message, e);
        };
        this.webSocket.onclose = function (e) {
            console.log('websocket onclose', e);
            self.webSocket = null;
            self.idCounter = 0;
            self.isAuthed = false;
            self.isBound = false;
            self.currentJid = null;
            self.roomSelfPresences = [];
            self.Fire('XmppDisconnected');
        };
        return this.webSocket;
    };
    CU.prototype.SendWebSocketChatMessage = function (messageType, room, input) {
        if (this.HasChatCurrentUser()) {
            if (this.HasRoomPresence(room)) {
                this.SendWebSocketMessageFromCurrentUser(messageType, room, input);
            }
            else {
                this.JoinRoomAsCurrentUser(room);
            }
        }
    };
    CU.prototype.HasWebSocket = function () {
        return this.webSocket !== null;
    };
    CU.prototype.HasOpenWebSocket = function () {
        return this.HasWebSocket() && this.webSocket.readyState == this.webSocket.OPEN;
    };
    CU.prototype.HasChatCurrentUser = function () {
        return this.HasOpenWebSocket() && this.isAuthed && this.isBound && this.currentJid && this.currentJid.HasUser();
    };
    CU.prototype.SendWebSocketMessage = function (msg) {
        if (this.HasOpenWebSocket()) {
            this.webSocket.send(msg.toString());
        }
        else {
            console.log('websocket error: tried sending message "' + msg.toString() + '" to closed web socket');
        }
    };
    CU.prototype.HasRoomPresence = function (room) {
        return this.roomSelfPresences.indexOf(room) !== -1;
    };
    CU.prototype.GetNextId = function () {
        return (++this.idCounter).toString(16);
    };
    CU.prototype.SendWebSocketMessageFromCurrentUser = function (messageType, room, input) {
        this.SendWebSocketMessage($msg({ to: room, from: room + '/' + this.currentJid.user, type: XmppMessageType[messageType].toLowerCase(), id: this.GetNextId() }).c('body').t(input));
    };
    CU.prototype.JoinRoomAsCurrentUser = function (room) {
        this.SendWebSocketMessage($pres({ to: room + '/' + this.currentJid.user }).c('x', { xmlns: 'http://jabber.org/protocol/muc' }));
    };
    CU.prototype.GetFirstElement = function (elements) {
        if (elements && elements.length !== 0) {
            return elements[0];
        }
    };
    CU.prototype.GetFirstElementValue = function (elements) {
        var first = this.GetFirstElement(elements);
        if (first) {
            return this.GetElementNodeValue(first);
        }
    };
    CU.prototype.GetElementNodeValue = function (element) {
        if (element.childNodes && element.childNodes.length !== 0) {
            return element.childNodes[0].nodeValue;
        }
    };
    CU.prototype.ParseXml = function (xml) {
        if (typeof DOMParser !== 'undefined') {
            var domParser = new DOMParser();
            return domParser.parseFromString(xml, 'text/xml');
        }
        else if (typeof ActiveXObject !== 'undefined' && new ActiveXObject('Microsoft.XMLDOM')) {
            var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
            xmlDoc.async = 'false';
            xmlDoc.loadXML(xml);
            return xmlDoc;
        }
        else {
            throw new Error('No XML parser found');
        }
    };
    CU.prototype.$openStream = function (attrs) {
        if (!_.isObject(attrs)) {
            attrs = {};
        }
        if (!_.isString(attrs.xmlns)) {
            attrs.xmlns = 'jabber:client';
        }
        if (!_.isString(attrs['xmlns:stream'])) {
            attrs['xmlns:stream'] = 'http://etherx.jabber.org/streams';
        }
        if (!_.isString(attrs.version)) {
            attrs.version = '1.0';
        }
        return {
            toString: function () {
                var data = [];
                for (var key in attrs) {
                    if (attrs.hasOwnProperty(key)) {
                        data.push(' ', key, '=\'', attrs[key], '\'');
                    }
                }
                return (attrs.hasOpenXmlTag ? '<?xml version=\'1.0\'?>' : '') + '<stream:stream' + data.join('') + '>';
            }
        };
    };
    CU.prototype.$closeStream = function () {
        return {
            toString: function () { return '</stream:stream>'; }
        };
    };
    CU.prototype.$auth = function (attrs) {
        if (!_.isObject(attrs))
            attrs = {};
        if (!_.isString(attrs.mechanism)) {
            attrs.mechanism = XmppAuthMechanism[XmppAuthMechanism.PLAIN];
        }
        else if (_.isNumber(attrs.mechanism)) {
            attrs.mechanism = XmppAuthMechanism[attrs.mechanism];
        }
        if (!_.isString(attrs.value)) {
            switch (XmppAuthMechanism[attrs.mechanism]) {
                case XmppAuthMechanism[XmppAuthMechanism.PLAIN]:
                    if (!_.isString(attrs.username) || !_.isString(attrs.password)) {
                        throw new Error('$auth with PLAIN mechanism requires username and password');
                    }
                    break;
                case XmppAuthMechanism[XmppAuthMechanism.CSELOGINTOKEN]:
                    if (!_.isString(attrs.loginToken)) {
                        throw new Error('$auth with CSELOGINTOKEN mechanism requires login token');
                    }
                    break;
            }
        }
        if (!_.isString(attrs.xmlns)) {
            attrs.xmlns = 'urn:ietf:params:xml:ns:xmpp-sasl';
        }
        return {
            toString: function () {
                var data = [];
                for (var key in attrs) {
                    if (attrs.hasOwnProperty(key) && key != 'value' && key != 'loginToken' && key != 'username' && key != 'password') {
                        data.push(' ', key, '=\'', attrs[key], '\'');
                    }
                }
                var value;
                if (attrs.value) {
                    value = attrs.value;
                }
                else {
                    switch (attrs.mechanism) {
                        case XmppAuthMechanism[XmppAuthMechanism.PLAIN]:
                            value = Base64.encode('\0' + attrs.username + '\0' + attrs.password);
                            break;
                        case XmppAuthMechanism[XmppAuthMechanism.CSELOGINTOKEN]:
                            value = Base64.encode(attrs.loginToken);
                            break;
                    }
                }
                return '<auth' + data.join('') + '>' + value + '</auth>';
            }
        };
    };
    return CU;
})();
var Tooltip = (function () {
    function Tooltip(elements, options) {
        if (options === void 0) { options = {}; }
        this.elements = elements;
        this.options = options;
        Tooltip.$window = Tooltip.$window || $(window);
        Tooltip.$container = Tooltip.$container || $('#tooltip');
        if (!Tooltip.$container.length) {
            Tooltip.$container = $('<div>').attr('id', 'tooltip').appendTo(document.body);
        }
        this.bindEvents();
    }
    Tooltip.prototype.show = function (e) {
        var $target = $(e.target);
        var title;
        if (_.isString(this.options.title)) {
            title = this.options.title;
        }
        else if (_.isFunction(this.options.title)) {
            title = this.options.title();
        }
        else {
            title = $target.attr('data-tooltip-title');
        }
        var hasTitle = !_.isEmpty(title);
        var content;
        if (_.isFunction(this.options.content)) {
            content = this.options.content();
        }
        else if (_.isString(this.options.content) || _.isObject(this.options.content)) {
            content = this.options.content;
        }
        else {
            content = $target.attr('data-tooltip-content');
        }
        if (_.isString(content)) {
            content = content.replace(/(?:\r\n|\r|\n)/g, '<br />');
        }
        var hasContent = !_.isEmpty(content);
        if (!hasTitle && !hasContent)
            return;
        clearTimeout(Tooltip.hideTimeout);
        Tooltip.hideTimeout = null;
        Tooltip.$container.empty();
        if (hasTitle) {
            $('<h1>').addClass('tooltip-title').text(title).appendTo(Tooltip.$container);
        }
        if (hasContent) {
            if (_.isString(content)) {
                $('<div>').addClass('tooltip-content').html(content).appendTo(Tooltip.$container);
            }
            else {
                $('<div>').addClass('tooltip-content').appendTo(Tooltip.$container).append(content);
            }
        }
        var offset = $target.offset();
        var left = offset.left + (this.options.leftOffset || 0);
        var windowWidth = Tooltip.$window.width() - 5;
        var containerWidth = Tooltip.$container.outerWidth();
        if (left + containerWidth > windowWidth) {
            left = windowWidth - containerWidth;
        }
        var top = offset.top - Tooltip.$container.height() + (this.options.topOffset || 0);
        Tooltip.$container.css({ left: left, top: top });
        var showDelay = _.isNumber(this.options.showDelay) ? this.options.showDelay : 800;
        Tooltip.showTimeout = setTimeout(function () { return Tooltip.$container.stop().fadeIn(200); }, showDelay);
    };
    Tooltip.prototype.hide = function (e) {
        clearTimeout(Tooltip.showTimeout);
        Tooltip.showTimeout = null;
        var hideDelay = _.isNumber(this.options.hideDelay) ? this.options.hideDelay : 400;
        Tooltip.hideTimeout = setTimeout(function () { return Tooltip.$container.stop().fadeOut(100); }, hideDelay);
    };
    Tooltip.prototype.move = function (left, top) {
        Tooltip.$container.css({ left: left, top: top });
    };
    Tooltip.prototype.destroy = function () {
        if (this.elements) {
            this.elements.unbind('mouseenter mouseleave');
        }
    };
    Tooltip.prototype.bindEvents = function () {
        if (this.elements) {
            if (_.isString(this.elements)) {
                $(this.elements).unbind('mouseenter mouseleave').hover(this.show.bind(this), this.hide.bind(this));
            }
            else if (_.isObject(this.elements)) {
                this.elements.unbind('mouseenter mouseleave').hover(this.show.bind(this), this.hide.bind(this));
            }
        }
        return this;
    };
    return Tooltip;
})();
var cu = new CU();
